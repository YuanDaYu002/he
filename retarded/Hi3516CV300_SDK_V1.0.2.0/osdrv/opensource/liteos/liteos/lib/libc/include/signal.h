/*----------------------------------------------------------------------------
 * Copyright (c) <2013-2015>, <Huawei Technologies Co., Ltd>
 * All rights reserved.
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright notice, this list of
 * conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list
 * of conditions and the following disclaimer in the documentation and/or other materials
 * provided with the distribution.
 * 3. Neither the name of the copyright holder nor the names of its contributors may be used
 * to endorse or promote products derived from this software without specific prior written
 * permission.
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *---------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------
 * Notice of Export Control Law
 * ===============================================
 * Huawei LiteOS may be subject to applicable export control laws and regulations, which might
 * include those applicable to Huawei LiteOS of U.S. and the country in which you are located.
 * Import, export and usage of Huawei LiteOS in any manner by you shall be in compliance with such
 * applicable export control laws and regulations.
 *---------------------------------------------------------------------------*/
/** @defgroup signal Signal
 *  @ingroup posix
*/
#ifndef _HWLITEOS_POSIX_SIGNAL_H
#define _HWLITEOS_POSIX_SIGNAL_H

#include <stddef.h>
#include "limits.h"
#include "sys/types.h"
#include "pthread.h"

#ifdef __cplusplus
#if __cplusplus
extern "C" {
#endif /* __cplusplus */
#endif /* __cplusplus */

typedef int sig_atomic_t;

#define SIGRTMIN                20
#define SIGRTMAX                32

struct timespec;

union sigval
{
    int     sival_int;  /* Integer signal value */
    void    *sival_ptr; /* Pointer signal value */
};

typedef struct
{
    int             si_signo;   /* signal number */
    int             si_code;    /* signal code */
    union sigval    si_value;   /* signal value */
} siginfo_t;

# define SI_USER	1   /* Signal sent by kill() */
# define SI_QUEUE	2   /* Signal sent by sigqueue() */
# define SI_TIMER	3   /* Signal generated by expiration of a timer set by timer_settime() */
# define SI_ASYNCIO	4   /* Signal generated by completion of an asynchronous I/O request */
# define SI_MESGQ	5   /* Signal generated by arrival of a message on an empty message queue */

typedef void (*sa_sighandler_t)(int);

typedef void (*sa_siginfoaction_t)(int, siginfo_t *, void *);

#define SIG_DFL ((sa_sighandler_t)NULL)      /* Request for default signal handling */
#define SIG_IGN ((sa_sighandler_t)NULL)      /* Request that signal be ignored */
#define SIG_ERR ((sa_sighandler_t)NULL)      /* Return value from signal() in case of error */

#define SIGHUP      1   /* Hangup */
#define SIGINT      2   /* Terminal interrupt signal */
#define SIGQUIT     3   /* Terminal quit signal */
#define SIGILL      4   /* Illegal instruction */
#define SIGTRAP     5   // Trace*breakpoint trap */
#define SIGABRT     6   /* Process abort signal */
#define SIGUSR2     7   /* User-defined signal 2 */
#define SIGFPE      8   /* Erroneous arithmetic operation */
#define SIGKILL     9   /* Kill (cannot be caught or ignored) */
#define SIGBUS      10  /* Access to an undefined portion of a memory object */
#define SIGSEGV     11  /* Invalid memory reference */
#define SIGSYS      12  /* Bad system call */
#define SIGPIPE     13  /* Write on a pipe with no one to read it */
#define SIGALRM     14  /* Alarm clock */
#define SIGTERM     15  /* Termination signal */
#define SIGUSR1     16  /* User-defined signal 1 */

typedef UINT32 sigset_t;

struct sigaction
{
    sigset_t                sa_mask;				/* Set of signals to be blocked during execution of the signal handling function */
    int                     sa_flags;				/* Special flags */
    union
    {
        sa_sighandler_t    sa_handler;				/* signal handler */
        sa_siginfoaction_t sa_sigaction;			/* Pointer to a signal-catching function */
    } sa_sigactionhandler;
#define sa_handler   sa_sigactionhandler.sa_handler
#define sa_sigaction sa_sigactionhandler.sa_sigaction
};

#define SA_NOCLDSTOP 1  /* Don't generate SIGCHLD when children stop or stopped children continue */
#define SA_SIGINFO   2  /* Causes extra information to be passed to signal handlers at the time of receipt of a signal */

struct sigevent
{
    int                  sigev_notify;  /* Notification type */
    int                  sigev_signo;   /* Signal number */
    union sigval         sigev_value;   /* Signal value  */
    void                (*sigev_notify_function) (union sigval); /* Notification function */
    void                *sigev_notify_attributes;   /* Notification attributes */
};

# define SIGEV_NONE     1   /* No asynchronous notification is delivered when the event of interest occurs */
# define SIGEV_SIGNAL   2   /* A queued signal, with an application-defined value, is generated when the event of interest occurs */
# define SIGEV_THREAD	3   /* A notification function is called to perform notification */

int kill(pid_t, int);
int pthread_kill(pthread_t, int);
int sigaction(int, const struct sigaction *, struct sigaction *);
int sigqueue(pid_t, int, const union sigval);
int sigprocmask(int, const sigset_t *, sigset_t *);
int pthread_sigmask(int, const sigset_t *, sigset_t *);
int sigpending(sigset_t *);

#define SIG_BLOCK       1
#define SIG_UNBLOCK     2
#define SIG_SETMASK     3

int sigsuspend(const sigset_t *);
int sigwait(const sigset_t *, int *);
int sigwaitinfo(const sigset_t *, siginfo_t *);
int sigtimedwait(const sigset_t *, siginfo_t *, const struct timespec *);
int sigemptyset(sigset_t *);
int sigfillset(sigset_t *);
int sigaddset(sigset_t *, int);
int sigdelset(sigset_t *, int);
int sigismember(const sigset_t *, int);
sa_sighandler_t signal(int, sa_sighandler_t);
int raise(int);


#ifdef __cplusplus
#if __cplusplus
}
#endif /* __cplusplus */
#endif /* __cplusplus */

#endif
